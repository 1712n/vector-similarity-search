// ⚠️ This file is auto-generated by wall-e (https://github.com/1712n/wall-e/).
// Do not edit it directly — instead, update the associated test/index.spec.* file and regenerate the code.

import { Client } from "pg";

const MODEL = "@cf/baai/bge-base-en-v1.5";
const BATCH = 100;

type Env = {
  AI: {
    run: (m: string, p: { text: string[] }) => Promise<{ data: number[][] }>;
  };
  HYPERDRIVE: { connectionString: string };
};

const log = (l: "INFO" | "ERROR", s: string, m: string, x: unknown = {}) =>
  console.log(JSON.stringify({ l, s, m, ...x }));

export default {
  async scheduled(_: ScheduledController, env: Env) {
    let db: Client | null = null;
    try {
      db = new Client({ connectionString: env.HYPERDRIVE.connectionString });
      await db.connect();
      log("INFO", "db", "connected");
    } catch (e) {
      log("ERROR", "db", "connect fail", { e: (e as Error).message });
      return;
    }

    let msgs: { id: number; content: string }[] = [];
    try {
      const q = `
    SELECT um.id, um.content
    FROM unique_messages um
    WHERE um.embedding IS NULL
      AND um.content <> ''
      AND EXISTS (
        SELECT 1 FROM message_feed mf
        WHERE mf.message_id = um.id
          AND mf.timestamp > (NOW() AT TIME ZONE 'UTC') - INTERVAL '1 day'
      )
   `;
      const res = await db.query(q);
      msgs = res.rows;
      log("INFO", "fetch", "msgs", { n: msgs.length });
    } catch (e) {
      log("ERROR", "fetch", "select fail", { e: (e as Error).message });
    }

    if (!msgs.length) {
      await db.end();
      return;
    }

    const ids: number[] = [];
    const vecTxt: string[] = [];
    for (let i = 0; i < msgs.length; i += BATCH) {
      const slice = msgs.slice(i, i + BATCH);
      try {
        const { data } = await env.AI.run(MODEL, {
          text: slice.map((v) => v.content),
        });
        data.forEach((v, j) => {
          ids.push(slice[j].id);
          vecTxt.push("[" + v.join(",") + "]");
        });
      } catch (e) {
        log("ERROR", "embed", "AI fail", { e: (e as Error).message });
      }
    }

    if (ids.length) {
      try {
        const upd = `
     WITH d(id, e) AS (SELECT * FROM UNNEST($1::int[], $2::text[]))
     UPDATE unique_messages u SET embedding = d.e::vector
     FROM d WHERE u.id = d.id
    `;
        await db.query(upd, [ids, vecTxt]);
        log("INFO", "embed", "stored", { n: ids.length });
      } catch (e) {
        log("ERROR", "embed", "update fail", { e: (e as Error).message });
      }
    }

    const t: string[] = [];
    const ind: string[] = [];
    const main: number[] = [];
    const sim: number[] = [];
    const mid: number[] = [];

    for (let i = 0; i < ids.length; i++) {
      try {
        const q = `
     WITH ranked AS (
       SELECT topic,
              industry,
              (embedding <=> $1::vector) dist,
              ROW_NUMBER() OVER (PARTITION BY topic, industry ORDER BY embedding <=> $1::vector) rn
       FROM synth_data_prod
     )
     SELECT topic, industry, 1 - dist AS s FROM ranked WHERE rn = 1
    `;
        const r = await db.query(q, [vecTxt[i]]);
        r.rows.forEach((row) => {
          t.push(row.topic);
          ind.push(row.industry);
          const sc = Number(row.s);
          main.push(sc);
          sim.push(sc);
          mid.push(ids[i]);
        });
      } catch (e) {
        log("ERROR", "sim", "calc fail", {
          id: ids[i],
          e: (e as Error).message,
        });
      }
    }

    if (mid.length) {
      try {
        const ins = `
     INSERT INTO message_scores (topic, industry, main, similarity, message_id)
     SELECT * FROM UNNEST($1::text[], $2::text[], $3::real[], $4::real[], $5::int[])
    `;
        await db.query(ins, [t, ind, main, sim, mid]);
        log("INFO", "insert", "scores", { n: mid.length });
      } catch (e) {
        log("ERROR", "insert", "scores fail", { e: (e as Error).message });
      }
    }

    await db.end();
  },
};
