// ⚠️ This file is auto-generated by wall-e (https://github.com/1712n/wall-e/).
// Do not edit it directly — instead, update the associated test/index.spec.* file and regenerate the code.

import { Client } from "pg";
export default {
  async scheduled(event, env) {
    let client;
    try {
      client = new Client({
        connectionString: env.HYPERDRIVE.connectionString,
      });
      await client.connect();
      console.info({ stage: "dbConnect", task: "connectDb" }, "DB connected");
      const newRes = await client.query(
        `SELECT id, content FROM unique_messages WHERE embedding IS NULL AND content<>'' AND id IN (SELECT DISTINCT message_id FROM message_feed WHERE timestamp>=NOW()-INTERVAL '1 day')`,
      );
      console.info(
        { stage: "fetchNew", count: newRes.rows.length },
        "Fetched new messages",
      );
      if (newRes.rows.length === 0) {
        await client.end();
        return;
      }
      const model = "embeddings-gecko-001";
      const batches = [];
      for (let i = 0; i < newRes.rows.length; i += 100)
        batches.push(newRes.rows.slice(i, i + 100));
      for (const batch of batches) {
        const texts = batch.map((r) => r.content);
        let aiResp;
        try {
          aiResp = await env.AI.run(model, { text: texts });
        } catch (e) {
          console.error(
            { stage: "aiEmbed", task: "runAI", error: e },
            "AI embedding error",
          );
          throw e;
        }
        const vals = [];
        const params = [];
        aiResp.data.forEach((emb, i) => {
          const id = batch[i].id;
          const vec = `[${emb.join(",")}]`;
          params.push(id, vec);
          const idx = params.length - 1;
          vals.push(`($${idx},$${idx + 1}::vector)`);
        });
        const updQ = `UPDATE unique_messages SET embedding=v.embedding FROM (VALUES${vals.join(
          ",",
        )}) AS v(id,embedding) WHERE unique_messages.id=v.id`;
        await client.query(updQ, params);
      }
      console.info(
        { stage: "updateEmb", task: "batchUpdate" },
        "Embeddings updated",
      );
      const pairRes = await client.query(
        `SELECT DISTINCT topic, industry FROM synth_data_prod`,
      );
      const pairs = pairRes.rows;
      const scores = [];
      for (const { id } of newRes.rows) {
        const embRow = await client.query(
          `SELECT embedding FROM unique_messages WHERE id=$1`,
          [id],
        );
        const embStr = embRow.rows[0].embedding;
        for (const { topic, industry } of pairs) {
          const simRes = await client.query(
            `SELECT embedding<=>$1::vector AS dist FROM synth_data_prod WHERE topic=$2 AND industry=$3 ORDER BY embedding<=>$1::vector LIMIT 1`,
            [embStr, topic, industry],
          );
          const dist = simRes.rows[0]?.dist ?? null;
          if (dist === null) continue;
          const sim = 1 / (1 + dist);
          scores.push({ topic, industry, sim, id });
        }
      }
      console.info(
        { stage: "calcSim", count: scores.length },
        "Similarity calculated",
      );
      if (scores.length > 0) {
        const params = [];
        const vals = scores.map((s, i) => {
          const idx = i * 5;
          params.push(s.topic, s.industry, s.sim, s.sim, s.id);
          return `($${idx + 1},$${idx + 2},$${idx + 3},$${idx + 4},$${idx + 5})`;
        });
        const insQ = `INSERT INTO message_scores(topic,industry,similarity,main,message_id) VALUES${vals.join(
          ",",
        )} ON CONFLICT(topic,industry,message_id) DO UPDATE SET similarity=EXCLUDED.similarity,main=COALESCE(message_scores.main,EXCLUDED.main)`;
        await client.query(insQ, params);
        console.info(
          { stage: "upsertScores", count: scores.length },
          "Scores upserted",
        );
      }
      await client.end();
      console.info({ stage: "complete" }, "Scheduled task completed");
    } catch (e) {
      console.error(
        { stage: "fatal", error: e },
        "Fatal error in scheduled worker",
      );
      if (client) await client.end();
      throw e;
    }
  },
};
