// ⚠️ This file is auto-generated by wall-e (https://github.com/1712n/wall-e/).
// Do not edit it directly — instead, update the associated test/index.spec.* file and regenerate the code.

import { Client } from "pg";

interface Env {
  AI: Ai;
  HYPERDRIVE: Hyperdrive;
}

interface MessageRow {
  id: number;
  content: string;
}

interface SimilarityResult {
  message_id: number;
  topic: string;
  industry: string;
  similarity: number;
}

export default {
  async scheduled(
    event: ScheduledEvent,
    env: Env,
    ctx: ExecutionContext,
  ): Promise {
    const client = new Client({
      connectionString: env.HYPERDRIVE.connectionString,
      connectionTimeoutMillis: 30000,
      query_timeout: 30000,
    });
    try {
      await client.connect();
      console.log("INFO: Database connection established");
      const oneDayAgo = new Date(
        Date.now() - 24 * 60 * 60 * 1000,
      ).toISOString();
      let messages: MessageRow[] = [];
      try {
        const selectQuery = `
          SELECT DISTINCT um.id, um.content
          FROM unique_messages um
          INNER JOIN message_feed mf ON um.id = mf.message_id
          WHERE um.embedding IS NULL
            AND mf.timestamp >= $1
            AND um.content != ''
          LIMIT 100
        `;
        const result = await client.query(selectQuery, [oneDayAgo]);
        messages = result.rows;
        console.log(
          `INFO: Selected ${messages.length} messages for processing`,
        );
      } catch (err) {
        console.error(
          `ERROR: Failed to select messages - ${err instanceof Error ? err.message : String(err)}`,
        );
        throw err;
      }
      if (messages.length === 0) {
        console.log("INFO: No messages to process");
        await client.end();
        return;
      }
      let embeddings: number[][] = [];
      try {
        const texts = messages.map((m) => m.content);
        const resp = await env.AI.run("@cf/baai/bge-m3", { text: texts });
        embeddings = resp.data as number[][];
        console.log(`INFO: Generated ${embeddings.length} embeddings`);
      } catch (err) {
        console.error(
          `ERROR: Failed to generate embeddings - ${err instanceof Error ? err.message : String(err)}`,
        );
        throw err;
      }
      try {
        for (let i = 0; i < messages.length; i++) {
          const embedding = embeddings[i];
          const formattedEmbedding = `[${embedding.join(",")}]`;
          await client.query(
            "UPDATE unique_messages SET embedding = $1::vector WHERE id = $2",
            [formattedEmbedding, messages[i].id],
          );
        }
        console.log(`INFO: Updated ${messages.length} embeddings in database`);
      } catch (err) {
        console.error(
          `ERROR: Failed to update embeddings - ${err instanceof Error ? err.message : String(err)}`,
        );
        throw err;
      }
      let similarities: SimilarityResult[] = [];
      try {
        const messageIds = messages.map((m) => m.id);
        const similarityQuery = `
          SELECT DISTINCT ON (m.id, s.topic, s.industry)
            m.id as message_id,
            s.topic,
            s.industry,
            1 - (m.embedding <=> s.embedding) AS similarity
          FROM unique_messages m
          CROSS JOIN synth_data_prod s
          WHERE m.id = ANY($1::int[])
            AND m.embedding IS NOT NULL
            AND s.embedding IS NOT NULL
          ORDER BY m.id, s.topic, s.industry, m.embedding <=> s.embedding
        `;
        const result = await client.query(similarityQuery, [messageIds]);
        similarities = result.rows;
        console.log(
          `INFO: Calculated ${similarities.length} similarity scores`,
        );
      } catch (err) {
        console.error(
          `ERROR: Failed to calculate similarities - ${err instanceof Error ? err.message : String(err)}`,
        );
        throw err;
      }
      if (similarities.length === 0) {
        console.log("INFO: No similarities to insert");
        await client.end();
        return;
      }
      try {
        const values = similarities
          .map((s, idx) => {
            const offset = idx * 5;
            return `($${offset + 1}, $${offset + 2}, $${offset + 3}, $${offset + 4}, $${offset + 5})`;
          })
          .join(",");
        const params: any[] = [];
        for (const s of similarities) {
          params.push(
            s.topic,
            s.industry,
            s.similarity,
            s.similarity,
            s.message_id,
          );
        }
        const insertQuery = `
          INSERT INTO message_scores (topic, industry, main, similarity, message_id)
          VALUES ${values}
          ON CONFLICT (message_id, topic, industry) DO UPDATE
          SET similarity = EXCLUDED.similarity,
              main = COALESCE(message_scores.main, EXCLUDED.similarity)
        `;
        await client.query(insertQuery, params);
        console.log(
          `INFO: Inserted ${similarities.length} scores into message_scores`,
        );
      } catch (err) {
        console.error(
          `ERROR: Failed to insert scores - ${err instanceof Error ? err.message : String(err)}`,
        );
        throw err;
      }
      await client.end();
      console.log("INFO: Processing completed successfully");
    } catch (err) {
      console.error(
        `ERROR: Worker execution failed - ${err instanceof Error ? err.message : String(err)}`,
      );
      try {
        await client.end();
      } catch (closeErr) {
        console.error(
          `ERROR: Failed to close connection - ${closeErr instanceof Error ? closeErr.message : String(closeErr)}`,
        );
      }
      throw err;
    }
  },
};
