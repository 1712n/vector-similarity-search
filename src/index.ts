// ⚠️ This file is auto-generated by wall-e (https://github.com/1712n/wall-e/).
// Do not edit it directly — instead, update the associated test/index.spec.* file and regenerate the code.

import { Client } from "pg";

interface Env {
  AI: any;
  HYPERDRIVE: { connectionString: string };
}

const MODEL = "text-embedding-ada-002";
const BATCH = 100;

export default {
  async scheduled(_: ScheduledController, env: Env, ctx: ExecutionContext) {
    ctx.waitUntil(run(env));
  },
};

async function run(env: Env) {
  const log = (lvl: string, stage: string, msg: string) =>
    console.log(`${lvl} ${stage} ${msg}`);
  let client: Client;
  try {
    client = new Client({ connectionString: env.HYPERDRIVE.connectionString });
    await client.connect();
  } catch (e) {
    log("ERROR", "db_connect", String(e));
    return;
  }

  try {
    const { rows: newMsgs } = await client.query(`
   SELECT um.id,um.content FROM unique_messages um
   JOIN message_feed mf ON mf.message_id=um.id
   WHERE um.embedding IS NULL
     AND mf.timestamp>=NOW()-INTERVAL '1 day'
     AND um.content<>''
   GROUP BY um.id,um.content
   LIMIT 1000
  `);
    if (!newMsgs.length) {
      log("INFO", "select", "no messages");
      await client.end();
      return;
    }

    for (let start = 0; start < newMsgs.length; start += BATCH) {
      const batch = newMsgs.slice(start, start + BATCH);
      const texts = batch.map((r) => r.content);
      let embeddings: any[];
      try {
        const r = await env.AI.run(MODEL, { text: texts });
        embeddings = r.data;
      } catch (e) {
        log("ERROR", "ai_embedding", String(e));
        continue;
      }

      const ids = batch.map((r) => r.id);
      const embedStrs = embeddings.map((v: any) => `[${v.join(",")}]`);
      const params: any[] = [];
      const valuePairs = ids
        .map((id, i) => {
          params.push(id, embedStrs[i]);
          return `($${params.length - 1}::int,$${params.length}::vector)`;
        })
        .join(",");
      try {
        await client.query(
          `UPDATE unique_messages u SET embedding=v.embed
     FROM (VALUES ${valuePairs}) v(id,embed) WHERE u.id=v.id`,
          params,
        );
      } catch (e) {
        log("ERROR", "update_embed", String(e));
      }

      try {
        const pairRows = await client.query(
          "SELECT DISTINCT topic,industry FROM synth_data_prod",
        );
        if (!pairRows.rowCount) continue;
        const pairCTE = pairRows.rows
          .map(
            (p, i) =>
              `SELECT $${i * 2 + 1}::text AS topic,$${i * 2 + 2}::text AS industry`,
          )
          .join(" UNION ALL ");
        const pairParams: any[] = [];
        pairRows.rows.forEach((p) => {
          pairParams.push(p.topic, p.industry);
        });

        const msgParams: any = [];
        const msgVals = ids
          .map((id, i) => {
            msgParams.push(id, embedStrs[i]);
            return `($${msgParams.length - 1}::int,$${msgParams.length}::vector)`;
          })
          .join(",");

        const qry = `
     WITH msgs(id,embed) AS (VALUES ${msgVals}),
     pairs AS (${pairCTE}),
     sims AS (
      SELECT m.id AS message_id,p.topic,p.industry,
       (SELECT 1-(sd.embedding<=>m.embed) FROM synth_data_prod sd
        WHERE sd.topic=p.topic AND sd.industry=p.industry
        ORDER BY sd.embedding<=>m.embed LIMIT 1) AS sim
      FROM msgs m CROSS JOIN pairs p
     )
     INSERT INTO message_scores(topic,industry,main,similarity,message_id)
     SELECT topic,industry,sim,sim,message_id FROM sims
    `;
        await client.query(qry, [...msgParams, ...pairParams]);
      } catch (e) {
        log("ERROR", "insert_scores", String(e));
      }
    }
  } catch (e) {
    log("ERROR", "processing", String(e));
  } finally {
    try {
      await client.end();
    } catch {}
  }
}
