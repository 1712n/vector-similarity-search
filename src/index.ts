// ⚠️ This file is auto-generated by wall-e (https://github.com/1712n/wall-e/).
// Do not edit it directly — instead, update the associated test/index.spec.* file and regenerate the code.

import { Client } from "pg";

// Constants
const MODEL_NAME = "@cf/baai/bge-base-en-v1.5";
const EMBEDDING_BATCH_SIZE = 10;

export default {
  async scheduled(
    event: ScheduledEvent,
    env: Env,
    ctx: ExecutionContext,
  ): Promise {
    console.log("INFO: Starting vector similarity processing");

    let client = null;

    try {
      client = new Client({
        connectionString: env.HYPERDRIVE.connectionString,
      });
      await client.connect();

      const messages = await getMessagesNeedingEmbeddings(client);
      if (messages.length === 0) {
        console.log("INFO: No messages found that need embeddings");
        return;
      }

      const messagesWithEmbeddings = await generateEmbeddings(messages, env);
      await updateEmbeddings(client, messagesWithEmbeddings);

      const topicIndustryPairs = await getTopicIndustryPairs(client);
      await updateSimilarityScores(
        client,
        messagesWithEmbeddings,
        topicIndustryPairs,
      );

      console.log("INFO: Vector similarity processing completed successfully");
    } catch (error) {
      console.error(
        `ERROR: Worker execution failed: ${error instanceof Error ? error.message : String(error)}`,
      );
    } finally {
      if (client) {
        await client.end();
      }
    }
  },
};

async function getMessagesNeedingEmbeddings(client) {
  try {
    const query = `
      SELECT DISTINCT um.id, um.content
      FROM unique_messages um
      JOIN message_feed mf ON um.id = mf.message_id
      WHERE um.embedding IS NULL
      AND um.content != ''
      AND mf.timestamp > NOW() - INTERVAL '1 day'
    `;

    const result = await client.query(query);
    console.log(
      `INFO: Found ${result.rows.length} messages needing embeddings`,
    );
    return result.rows;
  } catch (error) {
    console.error(
      `ERROR: Failed to get messages needing embeddings: ${error.message}`,
    );
    throw error;
  }
}

async function generateEmbeddings(messages, env) {
  try {
    const messagesWithEmbeddings = [];

    for (let i = 0; i < messages.length; i += EMBEDDING_BATCH_SIZE) {
      const batch = messages.slice(i, i + EMBEDDING_BATCH_SIZE);
      const texts = batch.map((msg) => msg.content);

      try {
        console.log(
          `INFO: Generating embeddings for batch ${Math.floor(i / EMBEDDING_BATCH_SIZE) + 1}/${Math.ceil(messages.length / EMBEDDING_BATCH_SIZE)}`,
        );
        const response = await env.AI.run(MODEL_NAME, { text: texts });

        for (let j = 0; j < batch.length; j++) {
          messagesWithEmbeddings.push({
            id: batch[j].id,
            content: batch[j].content,
            embedding: response.data[j],
          });
        }
      } catch (error) {
        console.error(
          `ERROR: Failed to generate embeddings for batch: ${error.message}`,
        );
        throw error;
      }
    }

    console.log(
      `INFO: Generated embeddings for ${messagesWithEmbeddings.length} messages`,
    );
    return messagesWithEmbeddings;
  } catch (error) {
    console.error(
      `ERROR: Failed in embedding generation process: ${error.message}`,
    );
    throw error;
  }
}

async function updateEmbeddings(client, messages) {
  try {
    await client.query("BEGIN");

    const updatePromises = messages.map((message) => {
      const formattedEmbedding = `[${message.embedding.join(",")}]`;
      return client.query(
        "UPDATE unique_messages SET embedding = $1::vector WHERE id = $2",
        [formattedEmbedding, message.id],
      );
    });

    await Promise.all(updatePromises);

    await client.query("COMMIT");
    console.log(`INFO: Updated embeddings for ${messages.length} messages`);
  } catch (error) {
    await client.query("ROLLBACK");
    console.error(`ERROR: Failed to update embeddings: ${error.message}`);
    throw error;
  }
}

async function getTopicIndustryPairs(client) {
  try {
    const query = `SELECT topic, industry, embedding FROM synth_data_prod`;
    const result = await client.query(query);

    console.log(`INFO: Found ${result.rows.length} topic-industry pairs`);
    return result.rows;
  } catch (error) {
    console.error(
      `ERROR: Failed to get topic-industry pairs: ${error.message}`,
    );
    throw error;
  }
}

async function updateSimilarityScores(client, messages, topicIndustryPairs) {
  try {
    await client.query("BEGIN");

    let updatedCount = 0;

    for (const message of messages) {
      const messageEmbeddingStr = `[${message.embedding.join(",")}]`;

      for (const pair of topicIndustryPairs) {
        try {
          const similarityResult = await client.query(
            `SELECT 1 - ($1::vector <=> $2::vector) AS similarity`,
            [messageEmbeddingStr, pair.embedding],
          );

          const similarity = similarityResult.rows[0].similarity;

          const existingResult = await client.query(
            `SELECT id, main FROM message_scores 
             WHERE message_id = $1 AND topic = $2 AND industry = $3`,
            [message.id, pair.topic, pair.industry],
          );

          if (existingResult.rows.length > 0) {
            const { id, main } = existingResult.rows[0];
            const newMain = main === null ? similarity : main;

            await client.query(
              `UPDATE message_scores SET similarity = $1, main = $2 WHERE id = $3`,
              [similarity, newMain, id],
            );
          } else {
            await client.query(
              `INSERT INTO message_scores (topic, industry, similarity, main, message_id) 
               VALUES ($1, $2, $3, $4, $5)`,
              [pair.topic, pair.industry, similarity, similarity, message.id],
            );
          }

          updatedCount++;
        } catch (error) {
          console.error(
            `ERROR: Failed to update score for message ${message.id}, topic ${pair.topic}, industry ${pair.industry}: ${error.message}`,
          );
          throw error;
        }
      }
    }

    await client.query("COMMIT");
    console.log(`INFO: Updated ${updatedCount} similarity scores`);
  } catch (error) {
    await client.query("ROLLBACK");
    console.error(
      `ERROR: Failed to update similarity scores: ${error.message}`,
    );
    throw error;
  }
}
