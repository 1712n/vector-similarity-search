// ⚠️ This file is auto-generated by wall-e (https://github.com/1712n/wall-e/).
// Do not edit it directly — instead, update the associated test/index.spec.* file and regenerate the code.

import { Client } from "pg";

interface Env {
  AI: Ai;
  HYPERDRIVE: Hyperdrive;
}

interface MessageRow {
  id: number;
  content: string;
}

interface SimilarityResult {
  message_id: number;
  topic: string;
  industry: string;
  similarity: number;
}

export default {
  async scheduled(
    event: ScheduledEvent,
    env: Env,
    ctx: ExecutionContext,
  ): Promise {
    const client = new Client({
      connectionString: env.HYPERDRIVE.connectionString,
      connectionTimeoutMillis: 30000,
      query_timeout: 30000,
    });
    try {
      await client.connect();
      console.log("INFO: Database connected");
      const messages = await fetchMessagesToProcess(client);
      if (messages.length === 0) {
        console.log("INFO: No messages to process");
        return;
      }
      console.log(`INFO: Processing ${messages.length} messages`);
      const embeddings = await generateEmbeddings(env, messages);
      await updateMessageEmbeddings(client, messages, embeddings);
      const messageIds = messages.map((m) => m.id);
      const similarities = await calculateSimilarities(client, messageIds);
      if (similarities.length > 0) {
        await insertScores(client, similarities);
        console.log(`INFO: Inserted ${similarities.length} scores`);
      }
    } catch (error) {
      console.error(
        `ERROR: Worker failed: ${error instanceof Error ? error.message : String(error)}`,
      );
      throw error;
    } finally {
      try {
        await client.end();
        console.log("INFO: Database connection closed");
      } catch (error) {
        console.error(
          `ERROR: Failed to close connection: ${error instanceof Error ? error.message : String(error)}`,
        );
      }
    }
  },
};

async function fetchMessagesToProcess(client: Client): Promise<MessageRow[]> {
  try {
    const query = `
      SELECT DISTINCT um.id, um.content
      FROM unique_messages um
      INNER JOIN message_feed mf ON um.id = mf.message_id
      WHERE um.embedding IS NULL
        AND um.content != ''
        AND mf.timestamp > NOW() - INTERVAL '1 day'
      LIMIT 100
    `;
    const result = await client.query(query);
    console.log(`INFO: Fetched ${result.rows.length} messages`);
    return result.rows;
  } catch (error) {
    console.error(
      `ERROR: Failed to fetch messages: ${error instanceof Error ? error.message : String(error)}`,
    );
    throw error;
  }
}

async function generateEmbeddings(
  env: Env,
  messages: MessageRow[],
): Promise<number[][]> {
  try {
    const texts = messages.map((m) => m.content);
    const resp = await env.AI.run("@cf/baai/bge-m3", { text: texts });
    console.log(`INFO: Generated ${resp.data.length} embeddings`);
    return resp.data;
  } catch (error) {
    console.error(
      `ERROR: Failed to generate embeddings: ${error instanceof Error ? error.message : String(error)}`,
    );
    throw error;
  }
}

async function updateMessageEmbeddings(
  client: Client,
  messages: MessageRow[],
  embeddings: number[][],
): Promise {
  try {
    for (let i = 0; i < messages.length; i++) {
      const formattedEmbedding = `[${embeddings[i].join(",")}]`;
      await client.query(
        "UPDATE unique_messages SET embedding = $1 WHERE id = $2",
        [formattedEmbedding, messages[i].id],
      );
    }
    console.log(`INFO: Updated ${messages.length} embeddings`);
  } catch (error) {
    console.error(
      `ERROR: Failed to update embeddings: ${error instanceof Error ? error.message : String(error)}`,
    );
    throw error;
  }
}

async function calculateSimilarities(
  client: Client,
  messageIds: number[],
): Promise<SimilarityResult[]> {
  try {
    const query = `
      SELECT DISTINCT ON (m.id, s.topic, s.industry)
        m.id as message_id,
        s.topic,
        s.industry,
        1 - (m.embedding <=> s.embedding) AS similarity
      FROM unique_messages m
      CROSS JOIN synth_data_prod s
      WHERE m.id = ANY($1::int[])
        AND m.embedding IS NOT NULL
        AND s.embedding IS NOT NULL
      ORDER BY m.id, s.topic, s.industry, m.embedding <=> s.embedding
    `;
    const result = await client.query(query, [messageIds]);
    console.log(`INFO: Calculated ${result.rows.length} similarities`);
    return result.rows;
  } catch (error) {
    console.error(
      `ERROR: Failed to calculate similarities: ${error instanceof Error ? error.message : String(error)}`,
    );
    throw error;
  }
}

async function insertScores(
  client: Client,
  similarities: SimilarityResult[],
): Promise {
  try {
    const values = similarities
      .map(
        (s, i) =>
          `($${i * 5 + 1}, $${i * 5 + 2}, $${i * 5 + 3}, $${i * 5 + 4}, $${i * 5 + 5})`,
      )
      .join(",");
    const params = similarities.flatMap((s) => [
      s.topic,
      s.industry,
      s.similarity,
      s.similarity,
      s.message_id,
    ]);
    const query = `
      INSERT INTO message_scores (topic, industry, main, similarity, message_id)
      VALUES ${values}
      ON CONFLICT (message_id, topic, industry) DO UPDATE
      SET similarity = EXCLUDED.similarity,
          main = COALESCE(message_scores.main, EXCLUDED.similarity)
    `;
    await client.query(query, params);
  } catch (error) {
    console.error(
      `ERROR: Failed to insert scores: ${error instanceof Error ? error.message : String(error)}`,
    );
    throw error;
  }
}
