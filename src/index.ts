// ⚠️ This file is auto-generated by wall-e (https://github.com/1712n/wall-e/).
// Do not edit it directly — instead, update the associated test/index.spec.* file and regenerate the code.

import { Client } from "pg";

interface Env {
  AI: {
    run: (model: string, inputs: any) => Promise;
  };
  HYPERDRIVE: {
    connectionString: string;
  };
}

export default {
  async scheduled(
    event: ScheduledEvent,
    env: Env,
    ctx: ExecutionContext,
  ): Promise {
    try {
      console.log("INFO: Starting Vector Similarity Worker execution");

      const client = new Client({
        connectionString: env.HYPERDRIVE.connectionString,
      });
      await client.connect();
      console.log("INFO: Connected to database");

      const unprocessedMessages = await getUnprocessedMessages(client);
      console.log(
        `INFO: Found ${unprocessedMessages.length} unprocessed messages`,
      );

      if (unprocessedMessages.length === 0) {
        console.log("INFO: No unprocessed messages found, exiting");
        await client.end();
        return;
      }

      const messageEmbeddings = await generateEmbeddings(
        unprocessedMessages,
        env,
      );

      const referenceData = await getReferenceData(client);
      console.log(`INFO: Found ${referenceData.length} reference embeddings`);

      const allScores = calculateSimilarityScores(
        messageEmbeddings,
        referenceData,
      );

      await updateMessageScores(client, allScores);
      await updateMessageEmbeddings(client, messageEmbeddings);

      console.log(
        "INFO: Vector Similarity Worker execution completed successfully",
      );
      await client.end();
    } catch (error) {
      console.error(`ERROR: Worker execution failed: ${error.message}`);
      throw error;
    }
  },
};

async function getUnprocessedMessages(
  client: Client,
): Promise<{ id: number; content: string }[]> {
  try {
    const query = `
      SELECT DISTINCT um.id, um.content
      FROM unique_messages um
      JOIN message_feed mf ON um.id = mf.message_id
      WHERE um.embedding IS NULL
      AND um.content != ''
      AND mf.timestamp > NOW() - INTERVAL '1 day'
    `;
    return (await client.query(query)).rows;
  } catch (error) {
    console.error(
      `ERROR: Failed to get unprocessed messages: ${error.message}`,
    );
    throw error;
  }
}

async function generateEmbeddings(
  messages: { id: number; content: string }[],
  env: Env,
): Promise<{ id: number; embedding: number[] }[]> {
  try {
    const modelName = "@cf/baai/bge-large-en-v1.5";
    const messageEmbeddings = [];
    const batchSize = 100;

    for (let i = 0; i < messages.length; i += batchSize) {
      const batch = messages.slice(i, i + batchSize);
      const inputs = batch.map((msg) => msg.content);

      console.log(
        `INFO: Generating embeddings for batch ${Math.floor(i / batchSize) + 1}, size: ${batch.length}`,
      );
      const resp = await env.AI.run(modelName, { text: inputs });

      for (let j = 0; j < batch.length; j++) {
        messageEmbeddings.push({
          id: batch[j].id,
          embedding: resp.data[j],
        });
      }
    }

    console.log(
      `INFO: Generated embeddings for ${messageEmbeddings.length} messages`,
    );
    return messageEmbeddings;
  } catch (error) {
    console.error(`ERROR: Failed to generate embeddings: ${error.message}`);
    throw error;
  }
}

async function getReferenceData(
  client: Client,
): Promise<{ topic: string; industry: string; embedding: any }[]> {
  try {
    const query = `SELECT topic, industry, embedding FROM synth_data_prod`;
    return (await client.query(query)).rows;
  } catch (error) {
    console.error(`ERROR: Failed to get reference data: ${error.message}`);
    throw error;
  }
}

function calculateSimilarityScores(
  messageEmbeddings: { id: number; embedding: number[] }[],
  referenceData: { topic: string; industry: string; embedding: any }[],
): {
  message_id: number;
  topic: string;
  industry: string;
  similarity: number;
}[] {
  try {
    const scores = [];

    for (const message of messageEmbeddings) {
      for (const reference of referenceData) {
        const similarity = cosineSimilarity(
          message.embedding,
          reference.embedding,
        );
        scores.push({
          message_id: message.id,
          topic: reference.topic,
          industry: reference.industry,
          similarity: similarity,
        });
      }
    }

    console.log(`INFO: Generated ${scores.length} similarity scores`);
    return scores;
  } catch (error) {
    console.error(
      `ERROR: Failed to calculate similarity scores: ${error.message}`,
    );
    throw error;
  }
}

function cosineSimilarity(vec1: number[], vec2: any): number {
  try {
    const vec2Array = Array.isArray(vec2) ? vec2 : parseVector(vec2);

    let dotProduct = 0;
    let mag1 = 0;
    let mag2 = 0;

    for (let i = 0; i < vec1.length; i++) {
      dotProduct += vec1[i] * vec2Array[i];
      mag1 += vec1[i] * vec1[i];
      mag2 += vec2Array[i] * vec2Array[i];
    }

    const magnitude = Math.sqrt(mag1) * Math.sqrt(mag2);
    return magnitude === 0 ? 0 : dotProduct / magnitude;
  } catch (error) {
    console.error(
      `ERROR: Cosine similarity calculation failed: ${error.message}`,
    );
    return 0;
  }
}

function parseVector(vector: any): number[] {
  if (Array.isArray(vector)) {
    return vector;
  } else if (typeof vector === "string") {
    return JSON.parse(vector);
  } else {
    console.error(`ERROR: Unknown vector format: ${typeof vector}`);
    return [];
  }
}

async function updateMessageScores(
  client: Client,
  scores: {
    message_id: number;
    topic: string;
    industry: string;
    similarity: number;
  }[],
): Promise {
  try {
    if (scores.length === 0) return;

    const valueStrings = [];
    const valueParams = [];

    scores.forEach((score, i) => {
      const offset = i * 4;
      valueStrings.push(
        `($${offset + 1}, $${offset + 2}, $${offset + 3}, $${offset + 4})`,
      );
      valueParams.push(
        score.topic,
        score.industry,
        score.similarity,
        score.message_id,
      );
    });

    const query = `
      INSERT INTO message_scores (topic, industry, similarity, message_id)
      VALUES ${valueStrings.join(", ")}
      ON CONFLICT (topic, industry, message_id) DO UPDATE 
      SET similarity = EXCLUDED.similarity,
          main = CASE WHEN message_scores.main IS NULL THEN EXCLUDED.similarity ELSE message_scores.main END
    `;

    await client.query(query, valueParams);
    console.log(`INFO: Updated ${scores.length} message scores`);
  } catch (error) {
    console.error(`ERROR: Failed to update message scores: ${error.message}`);
    throw error;
  }
}

async function updateMessageEmbeddings(
  client: Client,
  messageEmbeddings: { id: number; embedding: number[] }[],
): Promise {
  try {
    if (messageEmbeddings.length === 0) return;

    const valueStrings = [];
    const valueParams = [];

    messageEmbeddings.forEach((msg, i) => {
      const offset = i * 2;
      valueStrings.push(`($${offset + 1}, $${offset + 2}::vector)`);
      valueParams.push(msg.id, `[${msg.embedding.join(",")}]`);
    });

    const query = `
      UPDATE unique_messages
      SET embedding = v.embedding
      FROM (VALUES ${valueStrings.join(", ")}) AS v(id, embedding)
      WHERE unique_messages.id = v.id::integer
    `;

    await client.query(query, valueParams);
    console.log(
      `INFO: Updated embeddings for ${messageEmbeddings.length} messages`,
    );
  } catch (error) {
    console.error(
      `ERROR: Failed to update message embeddings: ${error.message}`,
    );
    throw error;
  }
}
