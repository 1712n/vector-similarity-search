// ⚠️ This file is auto-generated by wall-e (https://github.com/1712n/wall-e/).
// Do not edit it directly — instead, update the associated test/index.spec.* file and regenerate the code.

import { Client } from "pg";

interface Env {
  AI: Ai;
  HYPERDRIVE: Hyperdrive;
}

interface MessageRow {
  id: number;
  content: string;
}

interface TopicIndustryPair {
  topic: string;
  industry: string;
}

interface SimilarityScore {
  message_id: number;
  topic: string;
  industry: string;
  similarity: number;
}

export default {
  async scheduled(
    event: ScheduledEvent,
    env: Env,
    ctx: ExecutionContext,
  ): Promise {
    const client = new Client({
      connectionString: env.HYPERDRIVE.connectionString,
      connectionTimeoutMillis: 30000,
      query_timeout: 30000,
    });
    try {
      await client.connect();
      console.log("INFO: Database connected");
      const messages = await this.fetchMessages(client);
      if (messages.length === 0) {
        console.log("INFO: No messages to process");
        await client.end();
        return;
      }
      console.log(`INFO: Processing ${messages.length} messages`);
      await this.generateEmbeddings(client, env, messages);
      const topicIndustryPairs = await this.fetchTopicIndustryPairs(client);
      console.log(
        `INFO: Found ${topicIndustryPairs.length} topic-industry pairs`,
      );
      const allScores = await this.calculateSimilarities(
        client,
        messages,
        topicIndustryPairs,
      );
      console.log(`INFO: Calculated ${allScores.length} similarity scores`);
      await this.insertScores(client, allScores);
      console.log("INFO: Processing complete");
      await client.end();
    } catch (error) {
      console.error(
        `ERROR: Worker failed: ${error instanceof Error ? error.message : String(error)}`,
      );
      try {
        await client.end();
      } catch (endError) {
        console.error(
          `ERROR: Failed to close connection: ${endError instanceof Error ? endError.message : String(endError)}`,
        );
      }
      throw error;
    }
  },

  async fetchMessages(client: Client): Promise<MessageRow[]> {
    try {
      const query = `
        SELECT DISTINCT um.id, um.content
        FROM unique_messages um
        INNER JOIN message_feed mf ON um.id = mf.message_id
        WHERE um.embedding IS NULL
          AND um.content != ''
          AND mf.timestamp >= NOW() - INTERVAL '1 day'
        LIMIT 100
      `;
      const result = await client.query(query);
      return result.rows;
    } catch (error) {
      console.error(
        `ERROR: fetchMessages failed: ${error instanceof Error ? error.message : String(error)}`,
      );
      throw error;
    }
  },

  async generateEmbeddings(
    client: Client,
    env: Env,
    messages: MessageRow[],
  ): Promise {
    try {
      const texts = messages.map((m) => m.content);
      const resp = await env.AI.run("@cf/baai/bge-m3", { text: texts });
      if (!resp.data || !Array.isArray(resp.data)) {
        throw new Error("Invalid AI response format");
      }
      for (let i = 0; i < messages.length; i++) {
        try {
          const embedding = resp.data[i];
          if (!Array.isArray(embedding)) {
            console.error(
              `ERROR: Invalid embedding for message ${messages[i].id}`,
            );
            continue;
          }
          const formattedEmbedding = `[${embedding.join(",")}]`;
          await client.query(
            "UPDATE unique_messages SET embedding = $1::vector WHERE id = $2",
            [formattedEmbedding, messages[i].id],
          );
        } catch (error) {
          console.error(
            `ERROR: Failed to update embedding for message ${messages[i].id}: ${error instanceof Error ? error.message : String(error)}`,
          );
        }
      }
      console.log(`INFO: Generated embeddings for ${messages.length} messages`);
    } catch (error) {
      console.error(
        `ERROR: generateEmbeddings failed: ${error instanceof Error ? error.message : String(error)}`,
      );
      throw error;
    }
  },

  async fetchTopicIndustryPairs(client: Client): Promise<TopicIndustryPair[]> {
    try {
      const query =
        "SELECT DISTINCT topic, industry FROM synth_data_prod WHERE embedding IS NOT NULL";
      const result = await client.query(query);
      return result.rows;
    } catch (error) {
      console.error(
        `ERROR: fetchTopicIndustryPairs failed: ${error instanceof Error ? error.message : String(error)}`,
      );
      throw error;
    }
  },

  async calculateSimilarities(
    client: Client,
    messages: MessageRow[],
    pairs: TopicIndustryPair[],
  ): Promise<SimilarityScore[]> {
    const allScores: SimilarityScore[] = [];
    const messageIds = messages.map((m) => m.id);
    for (const pair of pairs) {
      try {
        const query = `
          SELECT 
            m.id as message_id,
            $1::text as topic,
            $2::text as industry,
            1 - (m.embedding <=> s.embedding) AS similarity
          FROM unique_messages m
          CROSS JOIN LATERAL (
            SELECT embedding
            FROM synth_data_prod
            WHERE topic = $1 
              AND industry = $2
              AND embedding IS NOT NULL
            ORDER BY embedding <=> m.embedding
            LIMIT 1
          ) s
          WHERE m.id = ANY($3::int[])
            AND m.embedding IS NOT NULL
        `;
        const result = await client.query(query, [
          pair.topic,
          pair.industry,
          messageIds,
        ]);
        allScores.push(...result.rows);
      } catch (error) {
        console.error(
          `ERROR: calculateSimilarities failed for ${pair.topic}-${pair.industry}: ${error instanceof Error ? error.message : String(error)}`,
        );
      }
    }
    return allScores;
  },

  async insertScores(client: Client, scores: SimilarityScore[]): Promise {
    if (scores.length === 0) {
      console.log("INFO: No scores to insert");
      return;
    }
    try {
      const values = scores
        .map((s, i) => {
          const offset = i * 4;
          return `($${offset + 1}, $${offset + 2}, $${offset + 3}, $${offset + 4}, $${offset + 3})`;
        })
        .join(",");
      const params = scores.flatMap((s) => [
        s.topic,
        s.industry,
        s.similarity,
        s.message_id,
      ]);
      const query = `
        INSERT INTO message_scores (topic, industry, similarity, message_id, main)
        VALUES ${values}
        ON CONFLICT (message_id, topic, industry) 
        DO UPDATE SET 
          similarity = EXCLUDED.similarity,
          main = COALESCE(message_scores.main, EXCLUDED.similarity)
      `;
      await client.query(query, params);
      console.log(`INFO: Inserted ${scores.length} scores`);
    } catch (error) {
      console.error(
        `ERROR: insertScores failed: ${error instanceof Error ? error.message : String(error)}`,
      );
      throw error;
    }
  },
};
