// ⚠️ This file is auto-generated by wall-e (https://github.com/1712n/wall-e/).
// Do not edit it directly — instead, update the associated test/index.spec.* file and regenerate the code.

import { Client } from "pg";
interface Env {
  AI: { run: (model: string, body: unknown) => Promise<{ data: number[][] }> };
  HYPERDRIVE: { connectionString: string };
}
const MODEL = "@cf/baai/bge-base-en-v1.5";
const CHUNK = 100;
const log = (
  level: "INFO" | "ERROR",
  msg: string,
  ctx: Record<string, unknown> = {},
) => console.log(JSON.stringify({ level, msg, ...ctx }));
const chunk = (a: T[], n: number) =>
  Array.from({ length: Math.ceil(a.length / n) }, (_, i) =>
    a.slice(i * n, i * n + n),
  );
export default {
  async fetch() {
    return new Response("OK");
  },
  async scheduled(_: ScheduledController, env: Env) {
    const t0 = Date.now();
    let client: Client | undefined;
    try {
      client = new Client({
        connectionString: env.HYPERDRIVE.connectionString,
      });
      await client.connect();
      const sel = `SELECT um.id,um.content FROM unique_messages um
              JOIN message_feed mf ON mf.message_id=um.id
              WHERE um.embedding IS NULL AND mf.timestamp>NOW()-INTERVAL '1 day' AND um.content<>''
              GROUP BY um.id,um.content LIMIT $1`;
      const { rows } = await client.query<{ id: number; content: string }>(
        sel,
        [CHUNK],
      );
      if (!rows.length) {
        log("INFO", "no_messages", { dt: Date.now() - t0 });
        return;
      }
      log("INFO", "messages_selected", { cnt: rows.length });
      const embeddings: Record<number, string> = {};
      for (const part of chunk(rows, CHUNK)) {
        try {
          const texts = part.map((p) => p.content);
          const r = await env.AI.run(MODEL, { text: texts });
          part.forEach(
            (p, i) => (embeddings[p.id] = `[${r.data[i].join(",")}]`),
          );
        } catch (e) {
          log("ERROR", "ai_embedding", { err: (e as Error).message });
          return;
        }
      }
      const ids = Object.keys(embeddings).map(Number);
      const params: string[] = [];
      const vals: string[] = [];
      ids.forEach((id, i) => {
        params.push(`($${i * 2 + 1},$${i * 2 + 2}::vector)`);
        vals.push(id.toString(), embeddings[id]);
      });
      const upEmb = `UPDATE unique_messages AS u SET embedding=v.embedding
                FROM (VALUES ${params.join(",")}) AS v(id,embedding) WHERE u.id=v.id`;
      await client.query("BEGIN");
      await client.query(upEmb, vals);
      const ins = `INSERT INTO message_scores(topic,industry,similarity,main,message_id)
              SELECT s.topic,s.industry,1-(u.embedding<#>s.embedding) AS sim,NULL,u.id
              FROM unique_messages u JOIN synth_data_prod s ON TRUE
              WHERE u.id=ANY($1::int[])
              ON CONFLICT (topic,industry,message_id)
              DO UPDATE SET similarity=EXCLUDED.similarity,
                            main=COALESCE(message_scores.main,EXCLUDED.similarity)`;
      await client.query(ins, [ids]);
      await client.query("COMMIT");
      log("INFO", "processing_complete", {
        cnt: ids.length,
        dt: Date.now() - t0,
      });
    } catch (e) {
      if (client)
        try {
          await client.query("ROLLBACK");
        } catch {}
      log("ERROR", "worker_failed", { err: (e as Error).message });
    } finally {
      try {
        await client?.end();
      } catch {}
    }
  },
};
